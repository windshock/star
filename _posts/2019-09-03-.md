이유도 작성 필요.
el과 [Expression Language Injection](https://www.owasp.org/index.php/Expression_Language_Injection)으로 인한 
EL을 블랙리스트 필터링하는 방식이 기존 패치의 방식, 지속적인 우회
[https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
[https://www.blackhat.com/docs/us-14/materials/us-14-Novikov-The-New-Page-Of-Injections-Book-Memcached-Injections-WP.pdf](https://www.blackhat.com/docs/us-14/materials/us-14-Novikov-The-New-Page-Of-Injections-Book-Memcached-Injections-WP.pdf)
reflection이 가능하므로 exploit 가능
민감한 api (execute, eval 등)에서 caller의 method 접근제한이 추가되면 reflection 제한 가능

취약한 코드 패턴
[https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.server_side_template_injection](https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.server_side_template_injection)
[https://find-sec-bugs.github.io/bugs.htm#TEMPLATE_INJECTION_VELOCITY](https://find-sec-bugs.github.io/bugs.htm#TEMPLATE_INJECTION_VELOCITY)

추가 확인 필요
[https://openjdk.java.net/jeps/118](https://openjdk.java.net/jeps/118)
[https://bodden.de/pubs/hhl+17hardening.pdf](https://bodden.de/pubs/hhl+17hardening.pdf)

openjsk에서만 지원 하는 것도 확인 필요

@CallerSensitive annotation은 JVM이 사용하는 Annotation으로 reflection에 의한 호출을 무시하고 Reflection.getCallerClass()을 이용하여 CallerClass에 따라 호출 여부를 결정할 수 있습니다.
> A caller-sensitive method varies its behavior according to the class of its immediate caller. It discovers its caller’s class by invoking the `sun.reflect.Reflection.getCallerClass` method.

Oracle 시큐어코딩 가이드에 따르면 해당 기능은 호출자의 를 검증하는 immediate class loader로 SecurityManager를 우회하여 표준 API를 직접호출 하는 경우를 보완하기 위해 작성된 ([JEP 176](http://openjdk.java.net/jeps/176)) 표준입니다.

하는 [코드 형태](https://www.programcreek.com/java-api-examples/?class=sun.reflect.Reflection&method=getCallerClass)를 보입니다.
    @CallerSensitive
    public static java.util.Enumeration<Driver> getDrivers() {
        java.util.Vector<Driver> result = new java.util.Vector<>();
    
        Class<?> callerClass = Reflection.getCallerClass();
    
        // Walk through the loaded registeredDrivers.
        for(DriverInfo aDriver : registeredDrivers) {
            // If the caller does not have permission to load the driver then
            // skip it.
            if(isDriverAllowed(aDriver.driver, callerClass)) {
                result.addElement(aDriver.driver);
            } else {
                println("    skipping: " + aDriver.getClass().getName());
            }
        }
        return (result.elements());
    }

이것 외에 stacktrace 등의 방법이 존재합니다만, 성능은 JVM에서 지원하는 annotation이 가장 좋습니다.
 - [StackWalker](https://www.javaworld.com/article/3188289/java-9s-other-new-enhancements-part-5-stack-walking-api.html)
 - [WhoCalled](https://github.com/nallar/WhoCalled)

##참고 자료
[https://stackoverflow.com/questions/22626808/what-does-the-sun-reflect-callersensitive-annotation-mean](https://stackoverflow.com/questions/22626808/what-does-the-sun-reflect-callersensitive-annotation-mean)
[https://www.oracle.com/technetwork/java/seccodeguide-139067.html#9-8](https://www.oracle.com/technetwork/java/seccodeguide-139067.html#9-8)
[http://openjdk.java.net/jeps/176](http://openjdk.java.net/jeps/176)
[https://github.com/nallar/WhoCalled](https://github.com/nallar/WhoCalled)
<!--stackedit_data:
eyJoaXN0b3J5IjpbOTY3NzA5Nzc0LC0zMDg1MjgxNTksMTc2Nj
c1NDExNywxMjc2NzcyMjU1LDczMDk5ODExNl19
-->